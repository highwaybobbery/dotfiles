#!/usr/bin/env ruby
# frozen_string_literal: true

require 'optparse'
require 'pathname'
require 'yaml'
require 'io/console'
require 'shellwords'

class SwingTo
  def initialize
    @projects_dir = File.expand_path('~/Projects')
    @repos_config = load_repos_config
    @repo_filter = nil
    @branch_filter = nil
    @branch_filter_failed = false
  end

  def run
    parse_options
    worktrees = discover_worktrees
    
    if worktrees.empty?
      if @repo_filter && @branch_filter
        puts "No worktrees found for repo '#{@repo_filter}' with branch '#{@branch_filter}' in #{@projects_dir}"
      elsif @repo_filter
        puts "No worktrees found for repo '#{@repo_filter}' in #{@projects_dir}"
      elsif @branch_filter
        puts "No worktrees found with branch '#{@branch_filter}' in #{@projects_dir}"
      else
        puts "No worktrees found in #{@projects_dir}"
      end
      exit 1
    end

    if worktrees.length == 1 && !@branch_filter_failed
      selected_worktree = worktrees.first
      puts "Auto-selecting only option: #{selected_worktree[:display_name]}"
    else
      if @branch_filter_failed
        puts "Branch filter '#{@branch_filter}' didn't match. Showing all branches for matching repo(s):"
      end
      selected_worktree = prompt_for_selection(worktrees)
    end
    change_directory(selected_worktree)
  end

  private

  def load_repos_config
    config_file = File.expand_path('~/Environment/repos.yml')
    unless File.exist?(config_file)
      puts "Error: repos.yml not found at #{config_file}"
      exit 1
    end
    YAML.load_file(config_file)
  end

  def fuzzy_match?(repo_name, filter)
    # Exact match
    return true if repo_name == filter
    
    # Case-insensitive exact match
    return true if repo_name.downcase == filter.downcase
    
    # Remove common separators and check if filter matches
    normalized_repo = repo_name.downcase.gsub(/[-_\s]/, '')
    normalized_filter = filter.downcase.gsub(/[-_\s]/, '')
    
    # Check if filter is contained in normalized repo name
    return true if normalized_repo.include?(normalized_filter)
    
    # Check if repo name contains all characters of filter in order
    filter_chars = normalized_filter.chars
    repo_chars = normalized_repo.chars
    
    filter_index = 0
    repo_chars.each do |char|
      if filter_index < filter_chars.length && char == filter_chars[filter_index]
        filter_index += 1
      end
    end
    
    filter_index == filter_chars.length
  end

  def parse_options
    option_parser = OptionParser.new do |opts|
      opts.banner = "Usage: #{$0} [options] [repo_name] [branch_name]"
      opts.separator ""
      opts.separator "Interactive worktree navigation utility"
      opts.separator ""
      opts.separator "Arguments:"
      opts.separator "    repo_name                    Filter to show only worktrees for the specified repository"
      opts.separator "    branch_name                  Filter to show only worktrees matching the specified branch"
      opts.separator ""
      opts.separator "Options:"

      opts.on('-h', '--help', 'Show this help message') do
        puts opts
        exit
      end
    end

    begin
      option_parser.parse!
      @repo_filter = ARGV[0] if ARGV.length > 0
      @branch_filter = ARGV[1] if ARGV.length > 1
    rescue OptionParser::InvalidOption => e
      puts "Error: #{e.message}"
      puts option_parser
      exit 1
    end
  end

  def discover_worktrees
    all_worktrees = []
    matching_repo_worktrees = []
    
    @repos_config['owners'].each do |owner, repos|
      owner_path = Pathname.new(@projects_dir) / owner
      next unless owner_path.exist?

      repos.each_key do |repo_name|
        repo_matches = !@repo_filter || fuzzy_match?(repo_name, @repo_filter)
        next unless repo_matches || !@repo_filter
        
        # Check both workspace and direct structures
        [
          owner_path / "#{repo_name}-workspace",
          owner_path / repo_name
        ].each do |repo_path|
          next unless repo_path.exist?

          # Find all directories that could be worktrees
          repo_path.children.select(&:directory?).each do |potential_worktree|
            # Skip if it's a bare git repo (contains objects, refs, etc.)
            next if (potential_worktree / 'objects').exist?
            
            # Check if it's a git worktree (has .git file or directory)
            if (potential_worktree / '.git').exist?
              worktree_name = potential_worktree.basename.to_s
              
              worktree = {
                owner: owner,
                repo: repo_name,
                worktree: worktree_name,
                path: potential_worktree,
                display_name: "#{owner}/#{repo_name}/#{worktree_name}"
              }
              
              if repo_matches
                matching_repo_worktrees << worktree
              elsif !@repo_filter
                all_worktrees << worktree
              end
            end
          end
        end
      end
    end
    
    # Determine which worktrees to return
    if @repo_filter
      if @branch_filter
        # Both repo and branch filters specified
        branch_matches = matching_repo_worktrees.select { |w| fuzzy_match?(w[:worktree], @branch_filter) }
        if branch_matches.empty? && !matching_repo_worktrees.empty?
          # Repo matches but no branches match - show all branches for matching repos
          @branch_filter_failed = true
          matching_repo_worktrees
        else
          branch_matches
        end
      else
        # Only repo filter specified
        matching_repo_worktrees
      end
    else
      # No filters
      all_worktrees
    end.sort_by { |w| [w[:owner], w[:repo], w[:worktree]] }
  end

  def prompt_for_selection(worktrees)
    $stdout.puts "\nAvailable worktrees:"
    $stdout.puts "==================="
    
    # Group worktrees by owner and repository
    grouped = worktrees.group_by { |w| [w[:owner], w[:repo]] }
    
    index = 1
    current_owner = nil
    
    grouped.keys.sort.each do |owner, repo|
      # Print owner header if it's a new owner
      if owner != current_owner
        $stdout.puts unless current_owner.nil?
        $stdout.puts "#{owner.upcase}:"
        current_owner = owner
      end
      
      # Print repository header
      $stdout.puts "  #{repo}:"
      
      # Print worktrees for this repository
      grouped[[owner, repo]].sort_by { |w| w[:worktree] }.each do |worktree|
        $stdout.printf "    %2d) %s\n", index, worktree[:worktree]
        worktree[:display_index] = index
        index += 1
      end
      $stdout.puts
    end
    
    $stdout.puts "Select a worktree (1-#{worktrees.length}, or 'q' to quit):"
    $stdout.flush
    
    loop do
      $stdout.print "> "
      $stdout.flush
      input = $stdin.gets&.strip
      
      # Handle empty input (like when run non-interactively)
      if input.nil? || input.empty?
        $stdout.puts "No input received. Exiting."
        exit 1
      end
      
      case input
      when 'q', 'quit', 'exit'
        $stdout.puts "Goodbye!"
        exit 0
      when /^\d+$/
        selection = input.to_i
        selected_worktree = worktrees.find { |w| w[:display_index] == selection }
        
        if selected_worktree
          return selected_worktree
        else
          $stdout.puts "Invalid selection. Please enter a number between 1 and #{worktrees.length}."
        end
      else
        $stdout.puts "Invalid input. Please enter a number (1-#{worktrees.length}) or 'q' to quit."
      end
    end
  end

  def change_directory(worktree)
    target_dir = worktree[:path].to_s
    puts "\nSelected: #{worktree[:display_name]}"

    # Save selection to file for swingto-go command
    selection_file = File.expand_path('~/.swingto_selection')
    File.write(selection_file, target_dir)
  end
end

# Run the script
SwingTo.new.run
